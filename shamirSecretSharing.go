package main

import (
	"fmt"
	"crypto/rand"
	"crypto/subtle"
)

type ffElement uint8 // 8 bit field element type

func ffAddSub(a, b ffElement) ffElement {
	// In finite field arithmetic of GF256 field, 
	// addition of two elements is same as xor operation
	return a^b
}

func ffMul(a, b ffElement) ffElement {
	// The traditional way for multiplying GF256
	// elements requires multiplying the encoded
	// polynomials and then taking the modulus 
	// operation with an irrreducible polynomial.
	// To optimize this process, we use lookup 
	// tables for log and antilog values as used
	// in popular AES implementation which uses
	// GF256 filed and works on bytes of data
	var multiplication_output, zero_val, return_val ffElement
	multiplication_output = exp[(int(log[a]) + int(log[b])) % 255]
	// ConstantTimeByteEq function makes sure that 
	// all calls take the same time regardless of 
	// the values of its inputs. This way, 
	// an attacker can't use timing based attacks.
	// ref : https://stackoverflow.com/a/17603874
	if subtle.ConstantTimeByteEq(uint8(a), 0) == 1 {
		return_val = zero_val
	} else {
		return_val = multiplication_output
	}

	if subtle.ConstantTimeByteEq(uint8(b), 0) == 1 {
		return_val = zero_val
	} else {
		// This operation doen't do anything useful. 
		// It only ensures a constant number of 
		// assignments to stop the timing attacks.
		// ref: https://stackoverflow.com/a/17603874
		multiplication_output = zero_val
	}

	return return_val
}

func ffDiv(a, b ffElement) ffElement{
	// The traditional way for dividin GF256
	// elements requires using multiplicative 
	// inverses using the encoded
	// polynomials and then extended euclidean 
	// algorithm with an irrreducible polynomial.
	// To optimize this process, we use lookup 
	// tables for log and antilog values as used
	// in popular AES implementation which uses
	// GF256 filed and works on bytes of data
    if b == 0 {
		// Illegal move
		panic("divide by zero")
	}

	var div_output, zero_val, return_val ffElement
	sub := (int(log[a]) - int(log[b])) % 255
	if sub < 0 {
		sub += 255
	}

	return_val = exp[sub]
	div_output = return_val
	// ConstantTimeByteEq function makes sure that 
	// all calls take the same time regardless of 
	// the values of its inputs. This way, 
	// an attacker can't use timing based attacks.
	// ref : https://stackoverflow.com/a/17603874
	if subtle.ConstantTimeByteEq(uint8(a), 0) == 1 {
		return_val = zero_val
	} else {
		return_val = div_output
	}
	return return_val
}

func ffRandBytes(n ffElement) ([]byte, error) {
	// This is a popular way to securely generate 
	// random bytes
	randByte := make([]byte, n)
	_, err := rand.Read(randByte)
    if err != nil {
		return nil, err
	}

	return randByte, nil
}

func ffCreatePolynomial(secret ffElement, degree ffElement) []ffElement{
	// Each coefficient of the polynomial is
	// an element of the finite field GF256.
	// This implies that each element is 
	// 8 bit long.
	poly := make([]ffElement, degree+1)
	poly[0] = secret
	var i ffElement
	i = 1
	for ; i <= degree; {
		v, e := ffRandBytes(1)
		if e==nil{
			poly[i] = ffElement(v[0])
			i+=1
		}
	}
	fmt.Println("Poly is ",poly)
	return poly
}

func polyEval(p []ffElement, x ffElement, degree ffElement) ffElement{
    // Horner's method is used here 
    if x == 0 {
		return p[0]
	}
    var result ffElement = p[int(degree)];
    var i int = int(degree) - 1
    for ; i >= 0; {
      result = ffAddSub(ffMul(result, x), p[i])
      i -= 1
    }
    return result
  }

func ffLagrangeInterpolation(xypoints [][]ffElement, t ffElement) ffElement{
    // This is the go implementation of the 
    // popular lagrange's interpolation algorithm.
    // The operations of add/sub/multiplication/division
    // are replaced by their field operation counterpart.
    var x ffElement = 0
    var y ffElement = 0
    var i ffElement = 0
    for ; i < t; {
      var aX ffElement = xypoints[i][0]
      var aY ffElement = xypoints[i][1]
      var li ffElement = 1
      var j ffElement = 0
      for ; j < t; {
        var bX ffElement = xypoints[j][0]
        if (i != j) {
          li = ffMul(li, ffDiv(ffAddSub(x, bX), ffAddSub(aX, bX)))
        }
        j += 1
      }
      y = ffAddSub(y, ffMul(li, aY))
      i += 1
    }
    return y
  }


func main(){
	var secret ffElement
	var degree ffElement
	var num_shares ffElement
	var shares [][]ffElement
	fmt.Println("################################################################################")
	fmt.Println("Note: This program uses Shamir's secret sharing scheme to share 1 byte of data.")
	fmt.Println()
	fmt.Println("The functions in this program could be imported to share large files by sharing each byte of the file as secret.")
	fmt.Println()
	fmt.Println("This program uses GF256 (Galois Field of 256 elements) which is suitable for efficient computation.")
	fmt.Println()
	fmt.Println("To speed up the operations, we have used look-up tables as used in AES for finite field multiplication and division.")
	fmt.Println("################################################################################")
	fmt.Println()
	fmt.Println()
	fmt.Println("Please enter the secret you want to share encoded as an unsigned 8 bit number (0-255)")
	fmt.Scanln(&secret)
	fmt.Println("Please enter the threshold value (min. shares required to recreate the secret)")
	fmt.Scanln(&degree)
	degree -= 1
	fmt.Println("Please enter the maximum number of shares")
	fmt.Scanln(&num_shares)
	var i ffElement = 1
	p := ffCreatePolynomial(secret, degree)
	fmt.Println()
	fmt.Println("Polynomial created with coefficients as field elements of GF256...")
	fmt.Println()
	for ;i<=num_shares;{
		tmp := []ffElement{i, polyEval(p, i, degree)}
		shares = append(shares, tmp)
		i += 1
	}
	fmt.Println("Following shares are generated : ")
	fmt.Println(shares)
	fmt.Println("Executing Lagrange's interpolation on the first ",degree+1," shares")
	var secret_result ffElement = ffLagrangeInterpolation(shares, degree+1)
	fmt.Println("Interpolated secret after combining the shares: ",secret_result)

}


// Log and antilog lookup table for efficient calculations

var log = [256]ffElement{
		0x00, 0x00, 0x01, 0x19, 0x02, 0x32, 0x1a, 0xc6,
		0x03, 0xdf, 0x33, 0xee, 0x1b, 0x68, 0xc7, 0x4b,
		0x04, 0x64, 0xe0, 0x0e, 0x34, 0x8d, 0xef, 0x81,
		0x1c, 0xc1, 0x69, 0xf8, 0xc8, 0x08, 0x4c, 0x71,
		0x05, 0x8a, 0x65, 0x2f, 0xe1, 0x24, 0x0f, 0x21,
		0x35, 0x93, 0x8e, 0xda, 0xf0, 0x12, 0x82, 0x45,
		0x1d, 0xb5, 0xc2, 0x7d, 0x6a, 0x27, 0xf9, 0xb9,
		0xc9, 0x9a, 0x09, 0x78, 0x4d, 0xe4, 0x72, 0xa6,
		0x06, 0xbf, 0x8b, 0x62, 0x66, 0xdd, 0x30, 0xfd,
		0xe2, 0x98, 0x25, 0xb3, 0x10, 0x91, 0x22, 0x88,
		0x36, 0xd0, 0x94, 0xce, 0x8f, 0x96, 0xdb, 0xbd,
		0xf1, 0xd2, 0x13, 0x5c, 0x83, 0x38, 0x46, 0x40,
		0x1e, 0x42, 0xb6, 0xa3, 0xc3, 0x48, 0x7e, 0x6e,
		0x6b, 0x3a, 0x28, 0x54, 0xfa, 0x85, 0xba, 0x3d,
		0xca, 0x5e, 0x9b, 0x9f, 0x0a, 0x15, 0x79, 0x2b,
		0x4e, 0xd4, 0xe5, 0xac, 0x73, 0xf3, 0xa7, 0x57,
		0x07, 0x70, 0xc0, 0xf7, 0x8c, 0x80, 0x63, 0x0d,
		0x67, 0x4a, 0xde, 0xed, 0x31, 0xc5, 0xfe, 0x18,
		0xe3, 0xa5, 0x99, 0x77, 0x26, 0xb8, 0xb4, 0x7c,
		0x11, 0x44, 0x92, 0xd9, 0x23, 0x20, 0x89, 0x2e,
		0x37, 0x3f, 0xd1, 0x5b, 0x95, 0xbc, 0xcf, 0xcd,
		0x90, 0x87, 0x97, 0xb2, 0xdc, 0xfc, 0xbe, 0x61,
		0xf2, 0x56, 0xd3, 0xab, 0x14, 0x2a, 0x5d, 0x9e,
		0x84, 0x3c, 0x39, 0x53, 0x47, 0x6d, 0x41, 0xa2,
		0x1f, 0x2d, 0x43, 0xd8, 0xb7, 0x7b, 0xa4, 0x76,
		0xc4, 0x17, 0x49, 0xec, 0x7f, 0x0c, 0x6f, 0xf6,
		0x6c, 0xa1, 0x3b, 0x52, 0x29, 0x9d, 0x55, 0xaa,
		0xfb, 0x60, 0x86, 0xb1, 0xbb, 0xcc, 0x3e, 0x5a,
		0xcb, 0x59, 0x5f, 0xb0, 0x9c, 0xa9, 0xa0, 0x51,
		0x0b, 0xf5, 0x16, 0xeb, 0x7a, 0x75, 0x2c, 0xd7,
		0x4f, 0xae, 0xd5, 0xe9, 0xe6, 0xe7, 0xad, 0xe8,
		0x74, 0xd6, 0xf4, 0xea, 0xa8, 0x50, 0x58, 0xaf,
	}

var	exp = [256]ffElement{
		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
		0x1d, 0x3a, 0x74, 0xe8, 0xcd, 0x87, 0x13, 0x26,
		0x4c, 0x98, 0x2d, 0x5a, 0xb4, 0x75, 0xea, 0xc9,
		0x8f, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0,
		0x9d, 0x27, 0x4e, 0x9c, 0x25, 0x4a, 0x94, 0x35,
		0x6a, 0xd4, 0xb5, 0x77, 0xee, 0xc1, 0x9f, 0x23,
		0x46, 0x8c, 0x05, 0x0a, 0x14, 0x28, 0x50, 0xa0,
		0x5d, 0xba, 0x69, 0xd2, 0xb9, 0x6f, 0xde, 0xa1,
		0x5f, 0xbe, 0x61, 0xc2, 0x99, 0x2f, 0x5e, 0xbc,
		0x65, 0xca, 0x89, 0x0f, 0x1e, 0x3c, 0x78, 0xf0,
		0xfd, 0xe7, 0xd3, 0xbb, 0x6b, 0xd6, 0xb1, 0x7f,
		0xfe, 0xe1, 0xdf, 0xa3, 0x5b, 0xb6, 0x71, 0xe2,
		0xd9, 0xaf, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88,
		0x0d, 0x1a, 0x34, 0x68, 0xd0, 0xbd, 0x67, 0xce,
		0x81, 0x1f, 0x3e, 0x7c, 0xf8, 0xed, 0xc7, 0x93,
		0x3b, 0x76, 0xec, 0xc5, 0x97, 0x33, 0x66, 0xcc,
		0x85, 0x17, 0x2e, 0x5c, 0xb8, 0x6d, 0xda, 0xa9,
		0x4f, 0x9e, 0x21, 0x42, 0x84, 0x15, 0x2a, 0x54,
		0xa8, 0x4d, 0x9a, 0x29, 0x52, 0xa4, 0x55, 0xaa,
		0x49, 0x92, 0x39, 0x72, 0xe4, 0xd5, 0xb7, 0x73,
		0xe6, 0xd1, 0xbf, 0x63, 0xc6, 0x91, 0x3f, 0x7e,
		0xfc, 0xe5, 0xd7, 0xb3, 0x7b, 0xf6, 0xf1, 0xff,
		0xe3, 0xdb, 0xab, 0x4b, 0x96, 0x31, 0x62, 0xc4,
		0x95, 0x37, 0x6e, 0xdc, 0xa5, 0x57, 0xae, 0x41,
		0x82, 0x19, 0x32, 0x64, 0xc8, 0x8d, 0x07, 0x0e,
		0x1c, 0x38, 0x70, 0xe0, 0xdd, 0xa7, 0x53, 0xa6,
		0x51, 0xa2, 0x59, 0xb2, 0x79, 0xf2, 0xf9, 0xef,
		0xc3, 0x9b, 0x2b, 0x56, 0xac, 0x45, 0x8a, 0x09,
		0x12, 0x24, 0x48, 0x90, 0x3d, 0x7a, 0xf4, 0xf5,
		0xf7, 0xf3, 0xfb, 0xeb, 0xcb, 0x8b, 0x0b, 0x16,
		0x2c, 0x58, 0xb0, 0x7d, 0xfa, 0xe9, 0xcf, 0x83,
		0x1b, 0x36, 0x6c, 0xd8, 0xad, 0x47, 0x8e, 0x00,
	}
